import os
from datetime import datetime
from typing import Iterable, Optional


from tach import filesystem as fs
from tach.check import check
from tach.colors import BCOLORS
from tach.constants import (
    CONFIG_FILE_NAME,
    PACKAGE_FILE_NAME,
    TOML_CONFIG_FILE_NAME,
    TOOL_NAME,
)
from tach.core import FullConfig, PackageConfig
from tach.errors import TachError
from tach.filesystem import canonical
from tach.parsing import dump_project_config_to_yaml, toml_config_exists

init_content_template = """# Generated by tach on {timestamp}
from .main import *
"""


def build_init_content():
    timestamp = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
    return init_content_template.format(timestamp=timestamp)


def build_package(path: str, tags: Optional[set[str]]) -> Optional[str]:
    dirname = path.removesuffix(".py")
    new_tag = canonical(dirname).replace(os.path.sep, ".")
    if not tags:
        tags_to_write = [new_tag]
    else:
        tags_to_write = tags
    if os.path.isfile(path):
        # Create the package directory
        os.mkdir(dirname)
        # Write the __init__
        fs.write_file(os.path.join(dirname, "__init__.py"), build_init_content())
        # Move and rename the file
        os.rename(path, os.path.join(dirname, "main.py"))
    # Write the package.yml
    comma_separated_tags = ",".join(map(lambda tag: f'"{tag}"', tags_to_write))
    package_yml_content = f"tags: [{comma_separated_tags}]\n"
    fs.write_file(
        os.path.join(dirname, f"{PACKAGE_FILE_NAME}.yml"), package_yml_content
    )

    if not tags:
        return new_tag


def update_project_config(
    root: str, config: FullConfig, tags: set[str]
) -> Optional[str]:
    current_dir = fs.get_cwd()
    try:
        fs.chdir(root)
        check_errors = check(root, config=config)
        for error in check_errors:
            if error.is_tag_error:
                invalid_tags = set(error.invalid_tags)
                if error.source_tag in tags:
                    # A package with one of the added tags caused this error and should update its dependencies
                    config.project.add_dependencies_to_tag(
                        error.source_tag, error.invalid_tags
                    )
                if invalid_tags & tags:
                    # A package now depends on one of the added tags and should add the newly added tags
                    # Note that we should leave pre-existing invalid tags
                    config.project.add_dependencies_to_tag(
                        error.source_tag, list(invalid_tags & tags)
                    )

        if not toml_config_exists(root):
            # Only auto-update project config in YML for now
            tach_yml_path = os.path.join(root, f"{CONFIG_FILE_NAME}.yml")
            tach_yml_content = dump_project_config_to_yaml(config.project)
            fs.write_file(tach_yml_path, tach_yml_content)
        else:
            return (
                f"Cannot auto-update project config in {TOML_CONFIG_FILE_NAME}, "
                f"use '{TOOL_NAME} check' to guide manual updates."
            )

        # Relying on mutation of 'config' here
        check_errors = check(root, config=config)
        if check_errors:
            return (
                "Could not auto-detect all dependencies, "
                "use 'tach check' to finish initialization manually."
            )
    except Exception as e:
        fs.chdir(current_dir)
        raise e
    fs.chdir(current_dir)


def validate_path(path: str, config: Optional[FullConfig] = None) -> None:
    if not os.path.exists(path):
        raise TachError(f"{path} does not exist.")
    if os.path.isdir(path):
        # 'path' points to a directory
        # so we validate that it is a Python package without an existing package config
        if os.path.exists(
            os.path.join(path, f"{PACKAGE_FILE_NAME}.yml")
        ) or os.path.exists(os.path.join(path, f"{PACKAGE_FILE_NAME}.yaml")):
            raise TachError(f"{path} already contains a {PACKAGE_FILE_NAME}.yml")
        if not os.path.exists(os.path.join(path, "__init__.py")):
            raise TachError(
                f"{path} is not a valid Python package (no __init__.py found)."
            )
    else:
        # 'path' points to a file
        # so we validate that it is a Python file we can 'pivot' to a package
        print(
            f"{BCOLORS.WARNING}'{path}' will be moved into a new package. "
            f"You may need to update relative imports within this file.{BCOLORS.ENDC}"
        )
        if not path.endswith(".py"):
            raise TachError(f"{path} is not a Python file.")
        if os.path.exists(path.removesuffix(".py")):
            raise TachError("{path} already has a directory of the same name.")
        dirname = os.path.dirname(path)
        containing_package = config.packages.find_nearest(path) if config else None
        if (
            containing_package is not None
            and containing_package.config is not None
            and containing_package.config.strict
        ):
            # this is a file we are pivoting out from a strict package
            # so any of its imports from siblings will start to fail, actually all relative imports will fail
            print(
                f"{BCOLORS.WARNING}'{path}' is contained by a strict package. "
                f"You may need to update imports from '{dirname}' to come through __all__ in __init__.py{BCOLORS.ENDC}"
            )
    root = fs.find_project_config_yml_root(path)
    if not root:
        raise TachError(f"{CONFIG_FILE_NAME} does not exist in any parent directories")


def add_packages(
    root: str, paths: set[str], config: FullConfig, tags: Optional[set[str]] = None
) -> Iterable[str]:
    tags = tags or set()
    # Validate paths
    for path in paths:
        validate_path(path=path, config=config)
    # Build packages
    new_tags: set[str] = set()
    for path in paths:
        new_tag = build_package(path=path, tags=tags)
        if new_tag:
            new_tags.add(new_tag)
            config.packages.insert(
                PackageConfig(tags=[new_tag]), fs.file_to_module_path(path), []
            )
        else:
            config.packages.insert(
                PackageConfig(tags=list(tags)), fs.file_to_module_path(path), []
            )
    # Update project config
    warning = update_project_config(
        root=root, config=config, tags=tags if tags else new_tags
    )
    if warning:
        return [warning]
    return []
